Part-5-Connection-Pooling/
â”œâ”€â”€ pom.xml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â””â”€â”€ java/
â”‚   â”‚       â””â”€â”€ com/
â”‚   â”‚           â””â”€â”€ part5/
â”‚   â”‚               â”œâ”€â”€ Application.java
â”‚   â”‚               â”œâ”€â”€ config/
â”‚   â”‚               â”‚   â””â”€â”€ DataSourceConfig.java              <-- HikariCP setup
â”‚   â”‚               â”œâ”€â”€ controller/
â”‚   â”‚               â”‚   â””â”€â”€ UserController.java                <-- Sample endpoint
â”‚   â”‚               â””â”€â”€ monitor/
â”‚   â”‚                   â”œâ”€â”€ HikariPoolInspector.java           <-- Exposes pool stats
â”‚   â”‚                   â””â”€â”€ HikariPoolMonitor.java             <-- @Scheduled logger
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/
â”‚           â””â”€â”€ com/
â”‚               â””â”€â”€ part5/
â”‚                   â””â”€â”€ concurrency/
â”‚                       â””â”€â”€ HighConcurrencyTest.java          <-- JUnit 5 test
â””â”€â”€ src/
    â””â”€â”€ main/
        â””â”€â”€ resources/
            â””â”€â”€ application.properties                         <-- Port + Hikari config




The system faces issues with database
 connections under high concurrency, particularly during peak loads. You are required
 to use HikariCP for database connection pooling, but you must also implement a
 custom monitoring solution that logs when connections are waiting too long or are
 being underutilized. Your solution should optimize pool size based on usage patterns,
 and avoid simply increasing the pool size to resolve connection bottlenecks.




 How Your Code Resolves the Issues
1.  Using HikariCP for Pooling
Configured via DataSourceConfig.java and application.properties

Enables fast, efficient connection management

Custom properties like maximum-pool-size, idle-timeout, max-lifetime are tuned


2. ğŸ“Š Custom Monitoring with Logs
HikariPoolMonitor.java is a @Scheduled component that:

Uses HikariPoolMXBean to fetch live stats

Logs:

Active connections

Idle connections

Threads awaiting connections

System.out.printf("Connections => Active: %d, Idle: %d, Waiting: %d%n", active, idle, awaiting);

Detects:

â— Bottlenecks if many threads are waiting

â— Underutilization if pool is too idle

3.  Real-Time Pool Stats via Endpoint
HikariPoolInspector.java exposes pool stats on /api/monitor/pool

Returns JSON with current connection pool metrics

Helps track pool usage externally (e.g., Prometheus/Grafana or simple curl)

 4. Simulating Concurrency
HighConcurrencyTest.java runs 50 parallel API requests

Shows how the pool behaves under stress/load

Helps you tune the pool empirically â€” e.g., if all threads are waiting, increase maximumPoolSize

Strategic Takeaways


| Goal                         |  Solution                                                                 |
| ---------------------------- | ----------------------------------------------------------------------------- |
| ğŸ§µ Handle High Concurrency   | HikariCP with optimized properties                                            |
| ğŸ‘ï¸ Monitor in Real-Time     | `HikariPoolMonitor` + `@Scheduled` logging                                    |
| ğŸ“¡ On-Demand Inspection      | REST endpoint via `HikariPoolInspector`                                       |
| ğŸ“‰ Avoid Overprovisioning    | Tune pool size based on logs and test case behavior                           |
| âš™ï¸ Performance-Driven Tuning | Backed by load simulation with 50 concurrent requests (`HighConcurrencyTest`) |

 Summary
âœ”ï¸ You followed a diagnoseâ€“observeâ€“tune approach
âœ”ï¸ Avoided the naive "increase pool size" shortcut
âœ”ï¸ Delivered custom monitoring, live stats & test validation
âœ”ï¸ Solution is scalable, extensible, and production-friendly



